//: Playground - noun: a place where people can play

import UIKit

var str = "Hello, playground"

//Two Dimensional Arrays

//Write a function that takes a square 2-Dimensional array of Ints and rotates it 90 degrees

//Sample input:
let testArr = [[1,2,3],
               [4,5,6],
               [7,8,9]]

//Sample output:
let testArrOut = [[7,4,1],
                  [8,5,2],
                  [9,6,3]]

//Bonus: Handle arrays that are not square

let testArr2 = [[1,2,3,4],
                [5,6,7,8]]

let testArr2Out = [[5,1],
                   [6,2],
                   [7,3],
                   [8,4]]

func rotateArr<T>(arr2d: [[T]]) -> [[T]] {
    var returnArr = [[T]]()
    for j in 0..<arr2d.count {
        var tempArr = [T]()
        for i in (0..<arr2d.count).reversed() {
            tempArr.append(arr2d[i][j])
        }
        returnArr.append(tempArr)
    }
    return returnArr
}

rotateArr(arr2d: testArr)
rotateArr(arr2d: testArr2)

func rotateArr2<T>(arr2d: [[T]]) -> [[T?]] {
    let myCount = arr2d[0].count
    let nilArr = Array<T?>(repeating: nil, count: myCount)
    var returnArr = Array(repeating: nilArr, count: arr2d.count)
    for rowNumber in 0..<arr2d.count {
        for columnNumber in 0..<arr2d[0].count {
            returnArr[rowNumber][columnNumber] = arr2d[rowNumber][columnNumber]
        }
    }
    
    return returnArr
}


//Stacks

//Implement a Stack using an Array

class Stack<T> {
    private var arr = [T]()
    
    func pop() -> T? {
        return arr.removeLast()
    }
    
    func push(new: T) {
        arr.append(new)
    }
    
    func peek() -> T {
        return arr.last!
    }
    
    func isEmpty() -> Bool {
        return arr.count == 0
    }
    
    func map(closure: ((T) -> T)) -> Stack<T> {
        let finalStack = Stack<T>()
        
        for ele in self.arr {
            finalStack.push(new: closure(ele))
        }
        return finalStack
    }
}

let a = Stack<Int>()
a.push(new: 5)
a.push(new: 55)
a.push(new: 532)
a.push(new: 5134)
let map = a.map(closure: { $0 * $0 } )
dump(map)

//Linked Lists

//Implement a singly linked list with the following methods

class Node<T> {
    var key: T!
    var next: Node?
}

class LinkedList<T> {
    let head = Node<T>()
    
    func isEmpty() -> Bool {
        return head.key == nil
    }
    
    func append(new: T) {
        var currentNode = head
        let newNode = Node<T>()
        newNode.key = new

        while head.next != nil {
            currentNode = currentNode.next!
        }
        currentNode.next = newNode
    }
    
    func delete(at: Int) -> T? {
        var counter = 1
        var currentNode = head
        while counter < at {
            currentNode = currentNode.next!
            counter += 1
        }
        let returnKey = currentNode.key
        currentNode.key = nil
        return returnKey
    }
    
    func insert(at: Int, new: T) {
        var counter = 1
        var currentNode = head
        while counter < at - 1 {
            currentNode = currentNode.next!
            counter += 1
        }
        let newNode = Node<T>()
        newNode.key = new
        newNode.next = currentNode.next
        currentNode.next = newNode
    }
    
    var count: Int = 0
}


//Queues

//Implement a Queue using a Linked List.

class Queue<T> {
    private var list = LinkedList<T>()
    
    func enQueue(new: T) {
        self.list.append(new: new)
    }
    
    func deQueue() -> T? {
        guard !list.isEmpty() else { return nil }
        return list.delete(at: 0)
    }
    
    func peek() -> T? {
        guard !list.isEmpty() else { return nil }
        return list.head.key
    }
    
    func isEmpty() -> Bool {
        return list.isEmpty()
    }
}


//Advanced:

//1) Write map, filter and reduce functions for your Stack, Queue and LinkedList


//2) Write a reverse() function for your Stack, Queue and LinkedList

//2b) Write a reverse() funciton for your LinkedList that works in O(1) space


//3) https://projecteuler.net/problem=2
/*
 Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
 
 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
 
 By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
 */

//4) https://projecteuler.net/problem=7

/*
 By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
 
 What is the 10 001st prime number?
 */


